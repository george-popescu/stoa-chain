---
phase: 01-contract-verification
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - pact/stoa-coin/stoa-coin.repl
autonomous: true

must_haves:
  truths:
    - "coinbase function computes correct STOA emission and mints 90% to miner on non-0 chains"
    - "coinbase function on chain 0 mints 90% to miner plus injects 10% into UrStoa Vault"
    - "fund-tx defpact step 0 (buy-gas) debits sender for total gas amount"
    - "fund-tx defpact step 1 (redeem-gas) credits miner with fee and refunds sender the difference"
    - "buy-gas and redeem-gas direct functions work with GAS capability"
    - "cross-chain transfer debit on source chain and credit on target chain complete successfully for chains 0-9"
    - "cross-chain transfer fails for invalid chain IDs (chains >= 10)"
  artifacts:
    - path: "pact/stoa-coin/stoa-coin.repl"
      provides: "Complete runtime touchpoint verification tests"
      contains: "coinbase.*COINBASE"
  key_links:
    - from: "pact/stoa-coin/stoa-coin.repl"
      to: "coin.coinbase"
      via: "test-capability (COINBASE) + coinbase call"
      pattern: "test-capability.*COINBASE"
    - from: "pact/stoa-coin/stoa-coin.repl"
      to: "coin.fund-tx"
      via: "test-capability (GAS) + fund-tx call"
      pattern: "test-capability.*GAS"
    - from: "pact/stoa-coin/stoa-coin.repl"
      to: "coin.transfer-crosschain"
      via: "TRANSFER_XCHAIN capability + defpact steps"
      pattern: "transfer-crosschain"
---

<objective>
Verify all Haskell runtime touchpoints: coinbase emission computation (chain 0 and non-0), fund-tx defpact gas accounting (buy-gas/redeem-gas), and cross-chain transfer defpact across chains 0-9. Also test the direct buy-gas and redeem-gas functions used post-chainweb-2.24.

Purpose: These are the exact function calls and capability grants the Haskell runtime makes. If any of these fail, the node will not function. This plan proves compatibility before any Haskell code is modified.

Output: Extended `pact/stoa-coin/stoa-coin.repl` with all runtime touchpoint tests passing.
</objective>

<execution_context>
@/Users/codera/.claude/get-shit-done/workflows/execute-plan.md
@/Users/codera/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-contract-verification/01-RESEARCH.md
@.planning/phases/01-contract-verification/01-01-SUMMARY.md

# Key reference files
@/Users/codera/Development/Stoa/new-coin.pact
@/Users/codera/Development/Stoa/stoa-chain/pact/coin-contract/v5/coin-v5.repl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test coinbase emission on chain 0 and non-0 chains</name>
  <files>pact/stoa-coin/stoa-coin.repl</files>
  <action>
    Append tests to `pact/stoa-coin/stoa-coin.repl` that verify the STOA coinbase function. The STOA coinbase **ignores** the runtime-provided `amount` parameter and computes its own emission via `URC_Emissions`. This is intentional.

    **Test A: coinbase on chain 1 (non-0, 90% emission only)**

    ```pact
    (begin-tx "Coinbase on chain 1")
    (use coin)
    ;; Set chain 1 with a block-time in STOA year 0
    (env-chain-data {"chain-id": "1", "block-time": (time "2026-06-15T12:00:00Z")})

    ;; Grant COINBASE magic capability
    (test-capability (COINBASE))

    ;; Set miner keyset data (amount will be ignored by STOA coinbase)
    (env-data {"miner-ks": ["miner-key-1"]})
    (env-keys ["miner-key-1"])

    ;; Execute coinbase — the amount (2.304523) is passed by runtime but ignored
    (coinbase "miner1" (read-keyset "miner-ks") 2.304523)

    ;; Verify miner received a positive balance (the 90% block emission)
    (expect "miner1 balance is positive" true (> (get-balance "miner1") 0.0))

    ;; Capture the emission values for verification
    (let ((emissions (URC_Emissions)))
      (let ((block-em (at 0 emissions)) (urv-em (at 1 emissions)))
        ;; block emission should be positive
        (expect "block emission positive" true (> block-em 0.0))
        ;; urv emission should be positive
        (expect "urv emission positive" true (> urv-em 0.0))
        ;; miner on chain 1 gets exactly block-emission (90%)
        (expect "miner gets block emission" block-em (get-balance "miner1"))
      ))
    (commit-tx)
    ```

    **Test B: coinbase on chain 0 (90% + 10% vault injection)**

    This requires the UrStoa Vault to be initialized first via `A_InitialiseStoaChain`.

    ```pact
    (begin-tx "Initialize STOA chain on chain 0")
    (use coin)
    (env-chain-data {"chain-id": "0", "block-time": (time "2026-01-01T00:00:01Z")})

    ;; Grant GENESIS and COINBASE (as runtime does for genesis transactions)
    (test-capability (GENESIS))
    (test-capability (COINBASE))

    ;; Set foundation account data with one of the master keys
    (env-data {
      "foundation-ks": ["foundation-key-1"],
      "stoa-ns.stoa_master_one": ["master-key-1"]
    })
    (env-keys ["foundation-key-1", "master-key-1"])

    ;; Initialize STOA chain (creates foundation account, mints genesis supply, initializes vault)
    (A_InitialiseStoaChain "stoa-foundation" (read-keyset "foundation-ks"))

    ;; Verify genesis supply minted
    (expect "foundation has 16M STOA" 16000000.0 (get-balance "stoa-foundation"))

    ;; Verify UrStoa vault is initialized
    (expect "vault UrStoa supply is 1.0" 1.0 (UR_URV|VaultUrSupply))
    (commit-tx)

    ;; Now test coinbase on chain 0
    (begin-tx "Coinbase on chain 0 with vault injection")
    (use coin)
    (env-chain-data {"chain-id": "0", "block-time": (time "2026-06-15T12:00:00Z")})
    (test-capability (COINBASE))

    (env-data {"miner0-ks": ["miner-key-0"]})
    (env-keys ["miner-key-0"])

    ;; Capture vault STOA supply before coinbase
    (let ((vault-before (UR_URV|VaultSupply)))
      ;; Execute coinbase on chain 0
      (coinbase "miner0" (read-keyset "miner0-ks") 2.304523)

      (let ((emissions (URC_Emissions)))
        (let ((block-em (at 0 emissions)) (urv-em (at 1 emissions)))
          ;; miner on chain 0 gets block-emission + urv-emission (whole amount, then urv is transferred to vault)
          ;; After coinbase: miner balance = block-emission (because urv-emission was transferred to vault)
          (expect "miner0 has block emission" block-em (get-balance "miner0"))
          ;; Vault STOA supply increased by urv-emission
          (expect "vault supply increased" (+ vault-before urv-em) (UR_URV|VaultSupply))
        )))
    (commit-tx)
    ```

    **Test C: Verify emission formula at different dates**

    ```pact
    (begin-tx "Emission formula verification")
    (use coin)
    ;; Year 0 (2026): yearly emission should be ~4,840,000 STOA
    (env-chain-data {"block-time": (time "2026-06-15T12:00:00Z")})
    (let ((year-emission (UC_YearEmission 0)))
      (expect "Year 0 emission ~4840000" true
        (and (> year-emission 4839000.0) (< year-emission 4841000.0))))

    ;; Year 1 (2027): yearly emission should be ~4,754,059.405940594059
    (let ((year-emission (UC_YearEmission 1)))
      (expect "Year 1 emission ~4754059" true
        (and (> year-emission 4754000.0) (< year-emission 4755000.0))))

    ;; Year 2 (2028): yearly emission should be ~4,670,646.476412347117
    (let ((year-emission (UC_YearEmission 2)))
      (expect "Year 2 emission ~4670646" true
        (and (> year-emission 4670000.0) (< year-emission 4671000.0))))

    (commit-tx)
    ```

    NOTE: The `TRANSFER` capability in STOA is NOT managed (no `@managed`). This means `C_Transfer` used inside `C_URV|Inject` needs the TRANSFER capability to be acquired. The coinbase function on chain 0 calls `C_URV|Inject` -> `C_Transfer` which calls `transfer` -> acquires `(TRANSFER sender receiver amount)` which composes `(DEBIT sender)`. The miner account must be debitable. Since the miner was just credited, this should work if the miner's guard is satisfied. The test must set `env-keys` to include the miner's key.

    If the vault injection fails because the miner's DEBIT capability requires their keyset, and env-keys doesn't include it, adjust by adding the miner key to env-keys. The Haskell runtime sets up signers differently, but in REPL we must simulate this.
  </action>
  <verify>
    Run `pact pact/stoa-coin/stoa-coin.repl` — all coinbase-related expect assertions pass. Both chain 0 and non-0 paths work. Emission formula produces expected values for years 0, 1, 2.
  </verify>
  <done>
    1. Coinbase on non-0 chain mints correct 90% block emission to miner
    2. Coinbase on chain 0 mints 90% to miner and injects 10% into UrStoa Vault
    3. A_InitialiseStoaChain successfully creates foundation account with 16M STOA and initializes vault
    4. Emission formula produces correct values: ~4.84M (year 0), ~4.75M (year 1), ~4.67M (year 2)
  </done>
</task>

<task type="auto">
  <name>Task 2: Test fund-tx defpact and direct buy-gas/redeem-gas</name>
  <files>pact/stoa-coin/stoa-coin.repl</files>
  <action>
    Append tests to `pact/stoa-coin/stoa-coin.repl` that verify gas operations. The Haskell runtime calls these in two modes:

    **Mode 1: fund-tx defpact (pre-chainweb 2.24)** — 2-step defpact where step 0 = buy-gas, step 1 = redeem-gas.

    ```pact
    (begin-tx "fund-tx defpact test")
    (use coin)
    (env-chain-data {"chain-id": "1", "block-time": (time "2026-06-15T12:00:00Z")})

    ;; Create and fund a sender account
    (env-data {"sender-ks": ["sender-key"], "miner-ftx-ks": ["miner-ftx-key"]})
    (env-keys ["sender-key", "miner-ftx-key"])

    (test-capability (COINBASE))
    (coinbase "sender-ftx" (read-keyset "sender-ks") 0.0)
    ;; sender-ftx now has block-emission balance from coinbase
    ;; We need more funds for testing, credit directly
    (test-capability (CREDIT "sender-ftx"))
    (credit "sender-ftx" (read-keyset "sender-ks") 10.0)

    ;; Step 0: buy-gas via fund-tx
    (test-capability (GAS))
    (fund-tx "sender-ftx" "miner-ftx" (read-keyset "miner-ftx-ks") 1.0)

    ;; Verify sender was debited by total (1.0 STOA for gas)
    (let ((sender-after-buy (get-balance "sender-ftx")))
      ;; sender should have (10.0 + block-emission - 1.0)
      (expect "sender debited by 1.0 for gas" true
        (> sender-after-buy 8.0)))

    ;; Step 1: redeem-gas (continue defpact)
    ;; Fee is the actual gas consumed (e.g., 0.4 out of 1.0 max)
    (env-data {"fee": 0.4})
    (continue-pact 1)

    ;; Verify gas accounting
    (expect "miner received fee of 0.4" 0.4 (get-balance "miner-ftx"))

    (commit-tx)
    ```

    **Mode 2: Direct buy-gas / redeem-gas (post-chainweb 2.24)**

    ```pact
    (begin-tx "Direct buy-gas / redeem-gas test")
    (use coin)
    (env-chain-data {"chain-id": "2", "block-time": (time "2026-06-15T12:00:00Z")})

    ;; Create and fund sender
    (env-data {"sender2-ks": ["sender2-key"], "miner2-ks": ["miner2-key"]})
    (env-keys ["sender2-key", "miner2-key"])

    (create-account "sender-bg" (read-keyset "sender2-ks"))
    (test-capability (CREDIT "sender-bg"))
    (credit "sender-bg" (read-keyset "sender2-ks") 5.0)

    ;; buy-gas: debit sender for total
    (test-capability (GAS))
    (buy-gas "sender-bg" 1.0)

    (expect "sender debited by 1.0 after buy-gas" 4.0 (get-balance "sender-bg"))

    ;; redeem-gas: credit miner with fee, refund sender remainder
    (env-data {"fee": 0.3, "miner2-ks": ["miner2-key"]})
    (redeem-gas "miner-bg" (read-keyset "miner2-ks") "sender-bg" 1.0)

    (expect "miner received 0.3 fee" 0.3 (get-balance "miner-bg"))
    (expect "sender refunded 0.7" 4.7 (get-balance "sender-bg"))

    (commit-tx)
    ```

    **Edge cases:**

    ```pact
    (begin-tx "Gas edge cases")
    (use coin)

    ;; GAS capability required
    (expect-failure "fund-tx fails without GAS"
      "not granted"
      (fund-tx "sender-bg" "miner-bg" (read-keyset "miner2-ks") 1.0))

    (expect-failure "buy-gas fails without GAS"
      "not granted"
      (buy-gas "sender-bg" 1.0))

    (commit-tx)
    ```

    Adjust account names and balances as needed to avoid conflicts with accounts created in Task 1.
  </action>
  <verify>
    Run `pact pact/stoa-coin/stoa-coin.repl` — all gas-related expect assertions pass. fund-tx defpact step 0 and step 1 complete correctly. Direct buy-gas and redeem-gas produce correct balances. GAS capability enforcement works.
  </verify>
  <done>
    1. fund-tx defpact step 0 debits sender by total gas amount
    2. fund-tx defpact step 1 credits miner with actual fee and refunds sender the remainder
    3. Direct buy-gas debits sender correctly
    4. Direct redeem-gas credits miner and refunds sender correctly
    5. Both paths require GAS magic capability (fail without it)
  </done>
</task>

<task type="auto">
  <name>Task 3: Test cross-chain transfer defpact across chains 0-9</name>
  <files>pact/stoa-coin/stoa-coin.repl</files>
  <action>
    Append tests to `pact/stoa-coin/stoa-coin.repl` that verify cross-chain transfers. The `transfer-crosschain` defpact has 2 steps:
    - Step 0: Debit sender on source chain, yield to target chain
    - Step 1: Resume on target chain, credit receiver

    **Test A: Cross-chain transfer from chain 0 to chain 5**

    ```pact
    (begin-tx "Cross-chain transfer: chain 0 -> chain 5")
    (use coin)
    (env-chain-data {"chain-id": "0"})
    (env-hash (hash "xchain-0-to-5"))

    ;; Set up sender with funds (use foundation account from earlier or create new)
    (env-data {"xsender-ks": ["xsender-key"], "xrecv-ks": ["xrecv-key"]})
    (env-keys ["xsender-key"])

    (create-account "xsender" (read-keyset "xsender-ks"))
    (test-capability (CREDIT "xsender"))
    (credit "xsender" (read-keyset "xsender-ks") 5.0)

    ;; Step 0: Debit on chain 0 (source)
    (test-capability (TRANSFER_XCHAIN "xsender" "xreceiver" 2.0 "5"))
    (transfer-crosschain "xsender" "xreceiver" (read-keyset "xrecv-ks") "5" 2.0)

    (expect "sender debited on source chain" 3.0 (get-balance "xsender"))

    ;; Step 1: Credit on chain 5 (target)
    (env-chain-data {"chain-id": "5"})
    (continue-pact 1 false (hash "xchain-0-to-5"))

    (expect "receiver credited on target chain" 2.0 (get-balance "xreceiver"))
    (commit-tx)
    ```

    **Test B: Cross-chain transfer fails for wrong target chain in yield**

    ```pact
    (begin-tx "Cross-chain: wrong chain in resume")
    (use coin)
    (env-chain-data {"chain-id": "3"})
    (env-hash (hash "xchain-wrong"))

    (env-data {"xsender2-ks": ["xsender2-key"], "xrecv2-ks": ["xrecv2-key"]})
    (env-keys ["xsender2-key"])

    (create-account "xsender2" (read-keyset "xsender2-ks"))
    (test-capability (CREDIT "xsender2"))
    (credit "xsender2" (read-keyset "xsender2-ks") 5.0)

    (test-capability (TRANSFER_XCHAIN "xsender2" "xreceiver2" 1.0 "7"))
    (transfer-crosschain "xsender2" "xreceiver2" (read-keyset "xrecv2-ks") "7" 1.0)

    ;; Try to resume on wrong chain (chain 3 instead of 7)
    (expect-failure "resume on wrong chain fails"
      "yield provenance"
      (continue-pact 1 false (hash "xchain-wrong")))

    (rollback-tx)
    ```

    **Test C: Cross-chain transfer to invalid chain (>= 10) fails**

    ```pact
    (begin-tx "Cross-chain: invalid chain ID")
    (use coin)
    (env-chain-data {"chain-id": "0"})

    (env-data {"xsender3-ks": ["xsender3-key"], "xrecv3-ks": ["xrecv3-key"]})
    (env-keys ["xsender3-key"])

    (create-account "xsender3" (read-keyset "xsender3-ks"))
    (test-capability (CREDIT "xsender3"))
    (credit "xsender3" (read-keyset "xsender3-ks") 5.0)

    ;; Chain 10 should fail (STOA has only 10 chains: 0-9)
    (expect-failure "transfer to chain 10 fails"
      "not a valid chainweb chain id"
      (transfer-crosschain "xsender3" "xreceiver3" (read-keyset "xrecv3-ks") "10" 1.0))

    ;; Chain 19 should also fail
    (expect-failure "transfer to chain 19 fails"
      "not a valid chainweb chain id"
      (transfer-crosschain "xsender3" "xreceiver3" (read-keyset "xrecv3-ks") "19" 1.0))

    ;; Same chain should fail
    (expect-failure "transfer to same chain fails"
      "same chain"
      (transfer-crosschain "xsender3" "xreceiver3" (read-keyset "xrecv3-ks") "0" 1.0))

    (rollback-tx)
    ```

    **Test D: Cross-chain between chains 8 and 9 (boundary)**

    ```pact
    (begin-tx "Cross-chain: chain 8 -> chain 9")
    (use coin)
    (env-chain-data {"chain-id": "8"})
    (env-hash (hash "xchain-8-to-9"))

    (env-data {"xsender4-ks": ["xsender4-key"], "xrecv4-ks": ["xrecv4-key"]})
    (env-keys ["xsender4-key"])

    (create-account "xsender4" (read-keyset "xsender4-ks"))
    (test-capability (CREDIT "xsender4"))
    (credit "xsender4" (read-keyset "xsender4-ks") 3.0)

    (test-capability (TRANSFER_XCHAIN "xsender4" "xreceiver4" 1.5 "9"))
    (transfer-crosschain "xsender4" "xreceiver4" (read-keyset "xrecv4-ks") "9" 1.5)

    (expect "sender debited" 1.5 (get-balance "xsender4"))

    (env-chain-data {"chain-id": "9"})
    (continue-pact 1 false (hash "xchain-8-to-9"))

    (expect "receiver credited on chain 9" 1.5 (get-balance "xreceiver4"))
    (commit-tx)
    ```

    Adjust the TRANSFER_XCHAIN capability acquisition as needed. In Kadena's v5, TRANSFER_XCHAIN is managed and requires `install-capability`. In STOA it is NOT managed (no @managed), so `test-capability` should suffice. If `test-capability` does not work for TRANSFER_XCHAIN (because it composes DEBIT which requires the sender's guard), use `env-sigs` with the sender's key and TRANSFER_XCHAIN capability instead.
  </action>
  <verify>
    Run `pact pact/stoa-coin/stoa-coin.repl` — all cross-chain expect assertions pass. Transfers work between valid chains (0-9), fail for invalid chains (10+), fail for same-chain, and fail when resumed on wrong chain.
  </verify>
  <done>
    1. Cross-chain transfer from chain 0 to chain 5 completes (debit + credit)
    2. Cross-chain transfer from chain 8 to chain 9 completes (boundary test)
    3. Transfer to chain >= 10 fails with "not a valid chainweb chain id"
    4. Transfer to same chain fails
    5. Resume on wrong chain fails with "yield provenance"
    6. STOA's 10-chain restriction (VALID_CHAIN_IDS 0-9) enforced correctly
  </done>
</task>

</tasks>

<verification>
Run the complete test file:
```bash
cd /Users/codera/Development/Stoa/stoa-chain
pact pact/stoa-coin/stoa-coin.repl
```
All assertions must pass. Zero failures.

Verify coverage:
- [x] CONT-04: fund-tx defpact (buy-gas step 0, redeem-gas step 1) with correct gas accounting
- [x] CONT-05: coinbase emission computation for year 0, 1, 2 and chain 0 vs non-0 behavior
- [x] CONT-06: Cross-chain transfer across chains 0-9 with invalid chain rejection
</verification>

<success_criteria>
- `pact pact/stoa-coin/stoa-coin.repl` completes with 0 failures
- Coinbase mints correct emissions (90% miner, 10% vault on chain 0)
- fund-tx defpact and direct buy-gas/redeem-gas produce correct balances
- Cross-chain transfers work for all valid chains (0-9) and reject invalid chains (10+)
- A_InitialiseStoaChain creates foundation with 16M STOA and initializes vault
</success_criteria>

<output>
After completion, create `.planning/phases/01-contract-verification/01-02-SUMMARY.md`
</output>
